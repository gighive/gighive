---
# roles/docker/tasks/main.yml

- name: Pre-create host htpasswd file to prevent Docker from making a directory
  become: true
  block:
    - name: Stat host htpasswd path
      ansible.builtin.stat:
        path: "{{ gighive_htpasswd_host_path }}"
      register: ghp

    - name: Remove miscreated directory at htpasswd path (if present)
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: absent
      when: ghp.stat.isdir | default(false)

    - name: Ensure parent dir for host htpasswd exists
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path | dirname }}"
        state: directory
        mode: "0750"

    - name: Create host htpasswd file if missing
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: touch
        mode: "0640"

    - name: Ensure host htpasswd file has correct ownership and permissions
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: file
        owner: www-data
        group: www-data
        mode: "0640"
  tags:
    - docker
    - htpasswd

- name: Ensure restore logs directory exists on host
  ansible.builtin.file:
    path: "{{ docker_dir }}/apache/externalConfigs/restorelogs"
    state: directory
    owner: www-data
    group: www-data
    mode: "0750"
  tags:
    - docker
    - restore

- name: Ensure “docker” group exists
  ansible.builtin.group:
    name: docker
    state: present
  tags: docker, permissions

- name: Add {{ ansible_user }} to Docker group
  ansible.builtin.user:
    name: "{{ ansible_user }}"
    groups: docker
    append: yes
  tags: docker, permissions

- name: Ensure Docker service is running
  ansible.builtin.systemd:
    name: docker
    state: started
    enabled: yes
  tags: docker

- name: Stage one-shot installer tarball for downloads (staging only)
  become: true
  block:
    - name: Ensure apache downloads directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/downloads"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0755"

    - name: Stat one-shot bundle inputs manifest on controller (if present)
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ one_shot_bundle_inputs_fingerprint_path }}.json"
      register: _one_shot_bundle_inputs_manifest_stat
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Load previous one-shot bundle inputs manifest (if present)
      delegate_to: localhost
      become: false
      ansible.builtin.slurp:
        src: "{{ one_shot_bundle_inputs_fingerprint_path }}.json"
      register: _one_shot_bundle_inputs_manifest_prev_slurp
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - _one_shot_bundle_inputs_manifest_stat.stat.exists | default(false)

    - name: Parse previous one-shot bundle inputs manifest (if present)
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_manifest_prev: "{{ (_one_shot_bundle_inputs_manifest_prev_slurp.content | b64decode | from_json) }}"
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - _one_shot_bundle_inputs_manifest_stat.stat.exists | default(false)

    - name: Initialize empty previous manifest when missing
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_manifest_prev: {}
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - not (_one_shot_bundle_inputs_manifest_stat.stat.exists | default(false))

    - name: Stat one-shot bundle input paths on controller
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ item }}"
      loop: "{{ one_shot_bundle_input_paths | default([]) }}"
      register: _one_shot_bundle_inputs_paths_stat
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Find files under monitored input directories on controller
      delegate_to: localhost
      become: false
      ansible.builtin.find:
        paths: "{{ item.stat.path }}"
        file_type: file
        recurse: true
        hidden: true
        patterns: "*"
        excludes:
          - "._*"
          - ".DS_Store"
      loop: "{{ _one_shot_bundle_inputs_paths_stat.results | selectattr('stat.isdir','defined') | selectattr('stat.isdir') | list }}"
      loop_control:
        label: "{{ item.stat.path }}"
      register: _one_shot_bundle_inputs_find_results
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Build flat list of monitored files (dirs + individual files)
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_files: >-
          {{
            (
              (_one_shot_bundle_inputs_find_results.results | default([]))
              | map(attribute='files')
              | list
              | flatten
              | map(attribute='path')
              | list
            )
            +
            (
              _one_shot_bundle_inputs_paths_stat.results
              | selectattr('stat.isreg','defined')
              | selectattr('stat.isreg')
              | map(attribute='stat.path')
              | list
            )
          }}
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Compute sha256 for monitored files (controller)
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ item }}"
        get_checksum: true
        checksum_algorithm: sha256
      loop: "{{ _one_shot_bundle_inputs_files | unique | sort }}"
      register: _one_shot_bundle_inputs_files_stat
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Initialize current manifest dict
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_manifest_now: {}
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Build current manifest mapping path->sha256
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_manifest_now: >-
          {{
            _one_shot_bundle_inputs_manifest_now
            | combine(item.stat.checksum | community.general.dict_kv(item.stat.path))
          }}
      loop: "{{ _one_shot_bundle_inputs_files_stat.results }}"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Compute added/removed paths
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_added: "{{ _one_shot_bundle_inputs_manifest_now.keys() | difference(_one_shot_bundle_inputs_manifest_prev.keys()) | sort }}"
        _one_shot_bundle_inputs_removed: "{{ _one_shot_bundle_inputs_manifest_prev.keys() | difference(_one_shot_bundle_inputs_manifest_now.keys()) | sort }}"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Initialize changed paths list
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_changed: []
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Compute changed paths (same path, different sha)
      ansible.builtin.set_fact:
        _one_shot_bundle_inputs_changed: "{{ _one_shot_bundle_inputs_changed + [item] }}"
      loop: "{{ _one_shot_bundle_inputs_manifest_now.keys() | intersect(_one_shot_bundle_inputs_manifest_prev.keys()) | list }}"
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - _one_shot_bundle_inputs_manifest_now[item] != _one_shot_bundle_inputs_manifest_prev[item]

    - name: Pause if one-shot bundle inputs changed (controller source)
      ansible.builtin.pause:
        prompt: |-
          ONE-SHOT BUNDLE INPUTS CHANGED.

          ADDED:
          {{ (_one_shot_bundle_inputs_added | default([])) | map('regex_replace','^(.*)$','  \\1') | join('\n') }}

          REMOVED:
          {{ (_one_shot_bundle_inputs_removed | default([])) | map('regex_replace','^(.*)$','  \\1') | join('\n') }}

          CHANGED:
          {{ (_one_shot_bundle_inputs_changed | default([])) | sort | map('regex_replace','^(.*)$','  \\1') | join('\n') }}

          REBUILD THE TGZ ON YOUR DEV BOX AND COPY IT TO THE STAGING CONTROLLER.
          THEN PRESS ENTER TO CONTINUE.
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - _one_shot_bundle_inputs_manifest_stat.stat.exists | default(false)
        - (_one_shot_bundle_inputs_added | length) > 0 or (_one_shot_bundle_inputs_removed | length) > 0 or (_one_shot_bundle_inputs_changed | length) > 0

    - name: Write current one-shot bundle inputs manifest (controller)
      delegate_to: localhost
      become: false
      ansible.builtin.copy:
        content: "{{ _one_shot_bundle_inputs_manifest_now | to_nice_json }}\n"
        dest: "{{ one_shot_bundle_inputs_fingerprint_path }}.json"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Write current one-shot bundle inputs fingerprint (controller)
      delegate_to: localhost
      become: false
      ansible.builtin.copy:
        content: "{{ (_one_shot_bundle_inputs_manifest_now | to_nice_json | hash('sha256')) }}\n"
        dest: "{{ one_shot_bundle_inputs_fingerprint_path }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Stat one-shot bundle tarball on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ one_shot_bundle_controller_src }}"
      register: _one_shot_bundle_controller_stat
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Fail if one-shot bundle is missing on controller (controller source)
      ansible.builtin.fail:
        msg: >-
          One-shot bundle tarball is required but was not found on the Ansible controller:
          {{ one_shot_bundle_controller_src }}
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - not (_one_shot_bundle_controller_stat.stat.exists | default(false))

    - name: Create one-shot bundle sha256 on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.command: sha256sum "{{ one_shot_bundle_controller_src }}"
      register: _one_shot_bundle_sha256
      changed_when: false
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Write one-shot bundle sha256 file on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.copy:
        content: "{{ _one_shot_bundle_sha256.stdout }}\n"
        dest: "{{ one_shot_bundle_controller_src }}.sha256"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Copy one-shot bundle tarball from controller into downloads directory (controller source)
      ansible.builtin.copy:
        src: "{{ one_shot_bundle_controller_src }}"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Copy one-shot bundle sha256 file from controller into downloads directory (controller source)
      ansible.builtin.copy:
        src: "{{ one_shot_bundle_controller_src }}.sha256"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}.sha256"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Download one-shot bundle tarball from staging into downloads directory (url source)
      ansible.builtin.get_url:
        url: "{{ one_shot_bundle_url }}"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'url'

  when: serve_one_shot_installer_downloads | default(false)
  tags:
    - docker
    - downloads

- name: Render bind-mounted docker config files
  block:
    # Ensure the host path exists where docker-compose will mount from
    - name: Ensure externalConfigs directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs"
        state: directory
        mode: "0755"

    - name: Stat ports.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
      register: _gighive_ports_conf_stat

    - name: Remove miscreated ports.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
        state: absent
      when: _gighive_ports_conf_stat.stat.isdir | default(false)

    - name: Copy ports.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/ports.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat logging.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
      register: _gighive_logging_conf_stat

    - name: Remove miscreated logging.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
        state: absent
      when: _gighive_logging_conf_stat.stat.isdir | default(false)

    - name: Copy logging.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/logging.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat apache2-logrotate.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
      register: _gighive_apache2_logrotate_conf_stat

    - name: Remove miscreated apache2-logrotate.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
        state: absent
      when: _gighive_apache2_logrotate_conf_stat.stat.isdir | default(false)

    - name: Copy apache2-logrotate.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/apache2-logrotate.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Ensure MySQL externalConfigs directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/mysql/externalConfigs"
        state: directory
        mode: "0755"

    # Render the vhost to a real file on the host (that the container will bind-mount)
    - name: Render guarded template bind-mounted config files
      ansible.builtin.include_tasks: render_guarded_template.yml
      loop:
        - src: .env.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/.env"
          mode: "0644"
        - src: .env.mysql.j2
          dest: "{{ docker_dir }}/mysql/externalConfigs/.env.mysql"
          mode: "0644"
        - src: entrypoint.sh.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/entrypoint.sh"
          mode: "0755"
        - src: apache2.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/apache2.conf"
          mode: "0644"
        - src: openssl_san.cnf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/openssl_san.cnf"
          mode: "0644"
        - src: modsecurity.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/modsecurity.conf"
          mode: "0644"
        - src: crs-setup.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/crs/crs-setup.conf"
          mode: "0644"
        - src: security2.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/security2.conf"
          mode: "0644"
        - src: php-fpm.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/php-fpm.conf"
          mode: "0644"
        - src: www.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/www.conf"
          mode: "0644"
        - src: default-ssl.conf.j2
          dest: "{{ docker_dir }}/apache/externalConfigs/default-ssl.conf"
          mode: "0644"
      loop_control:
        label: "{{ item.dest }}"

  tags: docker, compose

- name: Ensure tusd hooks directory exists
  ansible.builtin.file:
    path: "{{ docker_dir }}/tusd/hooks"
    state: directory
    mode: "0755"

- name: Deploy tusd post-finish hook
  ansible.builtin.copy:
    src: "tusd/hooks/post-finish"
    dest: "{{ docker_dir }}/tusd/hooks/post-finish"
    mode: "0755"

- name: Ensure API spec directory exists
  file:
    path: "{{ web_root }}/api"
    state: directory
    mode: "0755"

- name: Render Docker Compose file from Jinja2 template
  template:
    src: docker-compose.yml.j2
    dest: "{{ docker_dir }}/docker-compose.yml"
    mode: '0644'
  become: true
  become_user: "{{ ansible_user }}"
  register: docker_compose_template
  tags: docker, compose

- name: Assert gighive_fqdn is not an IP (must be hostname)
  assert:
    that:
      - (gighive_fqdn | default(gighive_server_name)) is regex("^[A-Za-z0-9.-]+$")  # naive host check, not IP
    fail_msg: "gighive_fqdn should be a hostname, not an IP."

- name: Stop Apache container for rebuild
  community.docker.docker_container:
    name: "{{ apache_container_name }}"
    state: absent
  ignore_errors: true
  tags: docker, compose

- name: Stop MySQL container for rebuild (when requested)
  community.docker.docker_container:
    name: "{{ mysql_container_name }}"
    state: absent
  when: (rebuild_mysql | default(false)) or (rebuild_mysql_data | default(false)) or (docker_compose_template.changed | default(false))
  ignore_errors: true
  tags: docker, compose

- name: Remove MySQL volume for complete rebuild (when requested)
  community.docker.docker_volume:
    name: "files_mysql_data"
    state: absent
  when: rebuild_mysql_data | default(false)
  ignore_errors: true
  tags: docker, compose

- name: Remove Apache image to force rebuild
  community.docker.docker_image:
    name: "{{ apache_docker_image }}"
    state: absent
  ignore_errors: true
  tags: docker, compose

- name: Start Docker Compose stack
  community.docker.docker_compose_v2:
    project_src: "{{ docker_dir }}"
    state: present
    build: always
  become: true
  register: compose_result
  failed_when: false
  changed_when: compose_result.changed
  tags: docker, compose

- name: Add current user to Docker group
  ansible.builtin.user:
    name: "{{ ansible_user }}"
    groups: docker
    append: yes
  tags: docker, permissions

- name: Ensure web root exists on target
  ansible.builtin.stat:
    path: "{{ web_root }}"
  register: web_root_status
  tags: docker, compose

- name: Abort if web root directory is missing
  ansible.builtin.fail:
    msg: "Web root directory {{ web_root_status.stat.path }} does not exist on remote host!"
  when: not web_root_status.stat.exists
  tags: docker, compose

- name: Ensure Docker project directory exists
  ansible.builtin.file:
    path: "{{ docker_dir }}"
    state: directory
    mode: '0755'
  tags: docker, compose

- name: Ensure python3-pip is installed
  ansible.builtin.apt:
    name:
      - python3-pip
    state: present
    update_cache: yes
  tags: docker, compose, prerequisites

- name: Debug Compose output
  ansible.builtin.debug:
    var: compose_result
    verbosity: 1
  tags: docker, compose

- name: Gather info on running Apache container
  community.docker.docker_container_info:
    name: "{{ apache_container_name }}"
  register: apache_info
  tags: docker, compose

- name: Dump full apache_info
  ansible.builtin.debug:
    var: apache_info
  tags: docker

- name: Assert Apache container exists and is running
  ansible.builtin.assert:
    that:
      - apache_info.container is not none
      - apache_info.container.State.Status == 'running'
    fail_msg: >-
      {{ apache_container_name }} container is not running or not present. Detected status:
      {{ apache_info.container.State.Status | default('missing') }}
  tags: docker, compose

- name: Gather info on running MySQL container
  community.docker.docker_container_info:
    name: "{{ mysql_container_name }}"
  register: mysql_info
  tags: docker, compose

- name: Dump full mysql_info
  ansible.builtin.debug:
    var: mysql_info
  tags: docker

- name: Assert MySQL container exists and is running
  ansible.builtin.assert:
    that:
      - mysql_info.container is not none
      - mysql_info.container.State.Status == 'running'
    fail_msg: >-
      {{ mysql_container_name }} container is not running or not present. Detected status:
      {{ mysql_info.container.State.Status | default('missing') }}
  tags: docker, compose

- name: Show running Apache container status
  ansible.builtin.debug:
    var: apache_info.container.State
  tags: docker, compose

- name: Show running MySQL container status
  ansible.builtin.debug:
    var: mysql_info.container.State
  tags: docker, compose
