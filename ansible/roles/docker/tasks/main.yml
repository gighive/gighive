---
# roles/docker/tasks/main.yml

- name: Pre-create host htpasswd file to prevent Docker from making a directory
  become: true
  block:
    - name: Stat host htpasswd path
      ansible.builtin.stat:
        path: "{{ gighive_htpasswd_host_path }}"
      register: ghp

    - name: Remove miscreated directory at htpasswd path (if present)
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: absent
      when: ghp.stat.isdir | default(false)

    - name: Ensure parent dir for host htpasswd exists
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path | dirname }}"
        state: directory
        mode: "0750"

    - name: Create host htpasswd file if missing
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: touch
        mode: "0640"

    - name: Ensure host htpasswd file has correct ownership and permissions
      ansible.builtin.file:
        path: "{{ gighive_htpasswd_host_path }}"
        state: file
        owner: www-data
        group: www-data
        mode: "0640"
  tags:
    - docker
    - htpasswd

- name: Ensure restore logs directory exists on host
  ansible.builtin.file:
    path: "{{ docker_dir }}/apache/externalConfigs/restorelogs"
    state: directory
    owner: www-data
    group: www-data
    mode: "0750"
  tags:
    - docker
    - restore

- name: Ensure “docker” group exists
  ansible.builtin.group:
    name: docker
    state: present
  tags: docker, permissions

- name: Add {{ ansible_user }} to Docker group
  ansible.builtin.user:
    name: "{{ ansible_user }}"
    groups: docker
    append: yes
  tags: docker, permissions

- name: Ensure Docker service is running
  ansible.builtin.systemd:
    name: docker
    state: started
    enabled: yes
  tags: docker

- name: Stage one-shot installer tarball for downloads (staging only)
  become: true
  block:
    - name: Ensure apache downloads directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/downloads"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0755"

    - name: Stat one-shot bundle tarball on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.stat:
        path: "{{ one_shot_bundle_controller_src }}"
      register: _one_shot_bundle_controller_stat
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Fail if one-shot bundle is missing on controller (controller source)
      ansible.builtin.fail:
        msg: >-
          One-shot bundle tarball is required but was not found on the Ansible controller:
          {{ one_shot_bundle_controller_src }}
      when:
        - (one_shot_bundle_source | default('controller')) == 'controller'
        - not (_one_shot_bundle_controller_stat.stat.exists | default(false))

    - name: Create one-shot bundle sha256 on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.command: sha256sum "{{ one_shot_bundle_controller_src }}"
      register: _one_shot_bundle_sha256
      changed_when: false
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Write one-shot bundle sha256 file on controller (controller source)
      delegate_to: localhost
      become: false
      ansible.builtin.copy:
        content: "{{ _one_shot_bundle_sha256.stdout }}\n"
        dest: "{{ one_shot_bundle_controller_src }}.sha256"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Copy one-shot bundle tarball from controller into downloads directory (controller source)
      ansible.builtin.copy:
        src: "{{ one_shot_bundle_controller_src }}"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Copy one-shot bundle sha256 file from controller into downloads directory (controller source)
      ansible.builtin.copy:
        src: "{{ one_shot_bundle_controller_src }}.sha256"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}.sha256"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'controller'

    - name: Download one-shot bundle tarball from staging into downloads directory (url source)
      ansible.builtin.get_url:
        url: "{{ one_shot_bundle_url }}"
        dest: "{{ docker_dir }}/apache/downloads/{{ one_shot_bundle_filename }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      when: (one_shot_bundle_source | default('controller')) == 'url'

  when: serve_one_shot_installer_downloads | default(false)
  tags:
    - docker
    - downloads

- name: Render bind-mounted docker config files
  block:
    # Ensure the host path exists where docker-compose will mount from
    - name: Ensure externalConfigs directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs"
        state: directory
        mode: "0755"

    - name: Stat ports.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
      register: _gighive_ports_conf_stat

    - name: Remove miscreated ports.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
        state: absent
      when: _gighive_ports_conf_stat.stat.isdir | default(false)

    - name: Copy ports.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/ports.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/ports.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat logging.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
      register: _gighive_logging_conf_stat

    - name: Remove miscreated logging.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
        state: absent
      when: _gighive_logging_conf_stat.stat.isdir | default(false)

    - name: Copy logging.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/logging.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/logging.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat apache2-logrotate.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
      register: _gighive_apache2_logrotate_conf_stat

    - name: Remove miscreated apache2-logrotate.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
        state: absent
      when: _gighive_apache2_logrotate_conf_stat.stat.isdir | default(false)

    - name: Copy apache2-logrotate.conf
      ansible.builtin.copy:
        src: "apache/externalConfigs/apache2-logrotate.conf"
        dest: "{{ docker_dir }}/apache/externalConfigs/apache2-logrotate.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Ensure MySQL externalConfigs directory exists
      ansible.builtin.file:
        path: "{{ docker_dir }}/mysql/externalConfigs"
        state: directory
        mode: "0755"

    - name: Render Docker env file
      ansible.builtin.template:
        src: .env.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render MySQL env file
      ansible.builtin.template:
        src: .env.mysql.j2
        dest: "{{ docker_dir }}/mysql/externalConfigs/.env.mysql"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render entrypoint.sh
      ansible.builtin.template:
        src: entrypoint.sh.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/entrypoint.sh"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0755"

    - name: Stat apache2.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2.conf"
      register: _gighive_apache2_conf_stat

    - name: Remove miscreated apache2.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/apache2.conf"
        state: absent
      when: _gighive_apache2_conf_stat.stat.isdir | default(false)

    - name: Render apache2.conf
      ansible.builtin.template:
        src: apache2.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/apache2.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render openssl_san.cnf
      ansible.builtin.template:
        src: openssl_san.cnf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/openssl_san.cnf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render modsecurity.conf
      ansible.builtin.template:
        src: modsecurity.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/modsecurity.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render crs/crs-setup.conf
      ansible.builtin.template:
        src: crs-setup.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/crs/crs-setup.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat security2.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/security2.conf"
      register: _gighive_security2_conf_stat

    - name: Remove miscreated security2.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/security2.conf"
        state: absent
      when: _gighive_security2_conf_stat.stat.isdir | default(false)

    - name: Render security2.conf
      ansible.builtin.template:
        src: security2.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/security2.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render php-fpm.conf
      ansible.builtin.template:
        src: php-fpm.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/php-fpm.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Render www.conf
      ansible.builtin.template:
        src: www.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/www.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Stat default-ssl.conf path (guard)
      ansible.builtin.stat:
        path: "{{ docker_dir }}/apache/externalConfigs/default-ssl.conf"
      register: _gighive_default_ssl_conf_stat

    - name: Remove miscreated default-ssl.conf directory (if present)
      ansible.builtin.file:
        path: "{{ docker_dir }}/apache/externalConfigs/default-ssl.conf"
        state: absent
      when: _gighive_default_ssl_conf_stat.stat.isdir | default(false)

    # Render the vhost to a real file on the host (that the container will bind-mount)
    - name: Render Apache SSL vhost (default-ssl.conf)
      ansible.builtin.template:
        src: default-ssl.conf.j2
        dest: "{{ docker_dir }}/apache/externalConfigs/default-ssl.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
  tags: docker, compose

- name: Ensure tusd hooks directory exists
  ansible.builtin.file:
    path: "{{ docker_dir }}/tusd/hooks"
    state: directory
    mode: "0755"

- name: Deploy tusd post-finish hook
  ansible.builtin.copy:
    src: "tusd/hooks/post-finish"
    dest: "{{ docker_dir }}/tusd/hooks/post-finish"
    mode: "0755"

- name: Ensure API spec directory exists
  file:
    path: "{{ web_root }}/api"
    state: directory
    mode: "0755"

#- name: Copy OpenAPI spec into Apache webroot
#  copy:
#    src: "api/openapi.yaml"          # resolved under roles/docker/files/
#    dest: "{{ web_root }}/api/openapi.yaml"
#    owner: www-data
#    group: www-data
#    mode: "0644"

- name: Render Docker Compose file from Jinja2 template
  template:
    src: docker-compose.yml.j2
    dest: "{{ docker_dir }}/docker-compose.yml"
    mode: '0644'
  become: true
  become_user: "{{ ansible_user }}"
  register: docker_compose_template
  tags: docker, compose

- name: Assert gighive_fqdn is not an IP (must be hostname)
  assert:
    that:
      - (gighive_fqdn | default(gighive_server_name)) is regex("^[A-Za-z0-9.-]+$")  # naive host check, not IP
    fail_msg: "gighive_fqdn should be a hostname, not an IP."

  # Removed deploy-time overlay: handled at build-time now


- name: Stop Apache container for rebuild
  community.docker.docker_container:
    name: "{{ apache_container_name }}"
    state: absent
  ignore_errors: true
  tags: docker, compose

- name: Stop MySQL container for rebuild (when requested)
  community.docker.docker_container:
    name: "{{ mysql_container_name }}"
    state: absent
  when: (rebuild_mysql | default(false)) or (rebuild_mysql_data | default(false)) or (docker_compose_template.changed | default(false))
  ignore_errors: true
  tags: docker, compose

- name: Remove MySQL volume for complete rebuild (when requested)
  community.docker.docker_volume:
    name: "files_mysql_data"
    state: absent
  when: rebuild_mysql_data | default(false)
  ignore_errors: true
  tags: docker, compose

- name: Remove Apache image to force rebuild
  community.docker.docker_image:
    name: "{{ apache_docker_image }}"
    state: absent
  ignore_errors: true
  tags: docker, compose

- name: Start Docker Compose stack
  community.docker.docker_compose_v2:
    project_src: "{{ docker_dir }}"
    state: present
    build: always
  become: true
  register: compose_result
  failed_when: false
  changed_when: compose_result.changed
  tags: docker, compose

- name: Add current user to Docker group
  ansible.builtin.user:
    name: "{{ ansible_user }}"
    groups: docker
    append: yes
  tags: docker, permissions

- name: Ensure web root exists on target
  ansible.builtin.stat:
    path: "{{ web_root }}"
  register: web_root_status
  tags: docker, compose

- name: Abort if web root directory is missing
  ansible.builtin.fail:
    msg: "Web root directory {{ web_root_status.stat.path }} does not exist on remote host!"
  when: not web_root_status.stat.exists
  tags: docker, compose

- name: Ensure Docker project directory exists
  ansible.builtin.file:
    path: "{{ docker_dir }}"
    state: directory
    mode: '0755'
  tags: docker, compose

- name: Ensure python3-pip is installed
  ansible.builtin.apt:
    name:
      - python3-pip
    state: present
    update_cache: yes
  tags: docker, compose, prerequisites

- name: Debug Compose output
  ansible.builtin.debug:
    var: compose_result
    verbosity: 1
  tags: docker, compose

- name: Gather info on running Apache container
  community.docker.docker_container_info:
    name: "{{ apache_container_name }}"
  register: apache_info
  tags: docker, compose

- name: Dump full apache_info
  ansible.builtin.debug:
    var: apache_info
  tags: docker

- name: Assert Apache container exists and is running
  ansible.builtin.assert:
    that:
      - apache_info.container is not none
      - apache_info.container.State.Status == 'running'
    fail_msg: >-
      {{ apache_container_name }} container is not running or not present. Detected status:
      {{ apache_info.container.State.Status | default('missing') }}
  tags: docker, compose

- name: Gather info on running MySQL container
  community.docker.docker_container_info:
    name: "{{ mysql_container_name }}"
  register: mysql_info
  tags: docker, compose

- name: Dump full mysql_info
  ansible.builtin.debug:
    var: mysql_info
  tags: docker

- name: Assert MySQL container exists and is running
  ansible.builtin.assert:
    that:
      - mysql_info.container is not none
      - mysql_info.container.State.Status == 'running'
    fail_msg: >-
      {{ mysql_container_name }} container is not running or not present. Detected status:
      {{ mysql_info.container.State.Status | default('missing') }}
  tags: docker, compose

- name: Show running Apache container status
  ansible.builtin.debug:
    var: apache_info.container.State
  tags: docker, compose

- name: Show running MySQL container status
  ansible.builtin.debug:
    var: mysql_info.container.State
  tags: docker, compose
