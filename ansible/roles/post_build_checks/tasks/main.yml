---
# roles/post_build_tasks/tasks/main.yml

- name: Verify containers are running after reboot
  ansible.builtin.shell: >
    docker ps --filter "name={{ apache_container_name }}" --filter "name={{ mysql_container_name }}" --format '{% raw %}{{.Names}}: {{.Status}}{% endraw %}'
  register: container_status
  changed_when: false

- name: Get primary interface name
  shell: ip -4 route get 1.1.1.1 | awk '{print $5; exit}'
  register: primary_iface
  changed_when: false

- name: Get NIC state (UP/DOWN)
  shell: ip -o link show {{ primary_iface.stdout }} | awk '{print $9}'
  register: nic_state
  changed_when: false

- name: Get primary IPv4 address
  shell: ip -4 addr show {{ primary_iface.stdout }} | grep inet | awk '{print $2}' | cut -d/ -f1
  register: ip_address
  changed_when: false

- name: Check multiple Docker containers
  community.docker.docker_container_info:
    name: "{{ item }}"
  register: container_info
  loop:
    - "{{ apache_container_name }}"
    - "{{ mysql_container_name }}"
  ignore_errors: true

- name: Fail if any container isn’t running
  fail:
    msg: "Container {{ item.item }} is not running (exists={{ item.exists }})"
  when:
    - item.exists
    - not item.container.State.Running
  loop: "{{ container_info.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: Check free memory
  shell: free -m | grep Mem | awk '{print $4}'
  register: mem_free
  changed_when: false

- name: Check free disk space
  shell: df -h / | grep -v Filesystem | awk '{print $4}'
  register: disk_free
  changed_when: false

- name: Check Docker service status
  service_facts:

- name: Get system load average
  shell: uptime | awk -F'load average:' '{ print $2 }' | sed 's/^[[:space:]]*//'
  register: load_avg
  changed_when: false

- name: Build Full Health Summary
  set_fact:
    summary:
      NIC_State: "{{ nic_state.stdout }}"
      IP_Address: "{{ ip_address.stdout }}"
      Containers_Running: >-
        {{ (container_info.results | selectattr('item', 'equalto', apache_container_name) | map(attribute='container.State.Running') | list | first)
            | default('Container Not Found') }}
      Free_Memory_MB: "{{ mem_free.stdout }}"
      Free_Disk_Space_Root: "{{ disk_free.stdout }}"
      Docker_Service_Running: "{{ ansible_facts['services']['docker'].state == 'running' if 'docker' in ansible_facts['services'] else 'Docker Not Found' }}"
      Load_Average: "{{ load_avg.stdout }}"

- name: Display Full Health Summary
  debug:
    var: summary

- name: Pause for X seconds to let the stack settle
  pause:
    seconds: 90 
    prompt: ""   # omit the “Press ENT

- name: Assert htpasswd exists on host (bind-mount source)
  ansible.builtin.stat:
    path: "{{ gighive_htpasswd_host_path }}"
  register: ht_host

- name: Fail if htpasswd missing on host
  ansible.builtin.fail:
    msg: "Expected htpasswd at {{ gighive_htpasswd_host_path }} (bind-mount to {{ gighive_htpasswd_path }}) but the file is missing on the host."
  when: not ht_host.stat.exists

# use shell builtin 'test' via sh -lc
- name: Check htpasswd readable inside container (root)
  ansible.builtin.command: docker exec -i "{{ apache_container_name }}" sh -lc 'test -r "{{ gighive_htpasswd_path }}"'
  register: ht_in_root
  changed_when: false
  failed_when: false

- name: Check htpasswd readable inside container as www-data
  ansible.builtin.command: docker exec -u www-data -i "{{ apache_container_name }}" sh -lc 'test -r "{{ gighive_htpasswd_path }}"'
  register: ht_in_www
  changed_when: false
  failed_when: false

# if either check fails, show useful details without printing file contents
- name: Show container mounts when htpasswd not visible (debug aid)
  ansible.builtin.command: >
    docker inspect -f '{{"{{"}}range .Mounts{{"}}"}}{{"{{"}}println .Source "->" .Destination{{"}}"}}{{"{{"}}end{{"}}"}}' "{{ apache_container_name }}"
  register: apache_mounts
  when: ht_in_root.rc != 0 or ht_in_www.rc != 0
  changed_when: false

- name: Show stat/owner seen inside container (no secrets)
  ansible.builtin.command: >
    docker exec -i "{{ apache_container_name }}" sh -lc
    'id;
     ls -l "{{ gighive_htpasswd_path }}" || true;
     stat -c "%A %U:%G %a %u:%g %n" "{{ gighive_htpasswd_path }}" || true'
  register: ht_stat
  when: ht_in_root.rc != 0 or ht_in_www.rc != 0
  changed_when: false

- name: Fail if htpasswd not readable inside container
  ansible.builtin.fail:
    msg: >
      htpasswd not readable at {{ gighive_htpasswd_path }}.
      root_rc={{ ht_in_root.rc }}, www_rc={{ ht_in_www.rc }}.
      Mounts:
      {{ apache_mounts.stdout | default('N/A') }}
      Stat:
      {{ ht_stat.stdout | default('N/A') }}
  when: ht_in_root.rc != 0 or ht_in_www.rc != 0

- name: Enable Apache headers module
  command: docker exec -i "{{ apache_container_name }}" a2enmod headers
  register: headers_mod
  changed_when: "'enabled' in (headers_mod.stdout | default(''))"
  failed_when: headers_mod.rc not in [0]
  tags: [hardening]

- name: Graceful reload Apache if headers was enabled
  command: docker exec -i "{{ apache_container_name }}" apache2ctl -k graceful
  when: "'enabled' in (headers_mod.stdout | default(''))"
  changed_when: false
  tags: [hardening]

# --- HTTP smoke tests ---

- name: Home should be public (200)
  uri:
    url: "{{ gighive_base_url }}/"
    method: GET
    validate_certs: "{{ gighive_validate_certs }}"
    return_content: no
    status_code: 200
    headers: "{{ {'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else omit }}"
  changed_when: false
  tags: [smoke]

- name: /src should require auth (401)
  uri:
    url: "{{ gighive_base_url }}/src/index.php"
    method: GET
    validate_certs: "{{ gighive_validate_certs }}"
    return_content: no
    status_code: 401
    headers: "{{ {'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else omit }}"
  changed_when: false
  tags: [smoke]

- block:
    - name: Webroot (probe)
      uri:
        url: "{{ gighive_base_url }}/"
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ {'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else omit }}"
        method: GET
        follow_redirects: all
        return_content: yes
        status_code: [200]      # keep it strict for now
      register: webroot_probe
      changed_when: false
      no_log: false             # TEMP: show status/headers/body if it fails
      tags: [smoke]

  rescue:
    - name: Show Apache error log tail (last 100 lines)
      command: docker exec -i "{{ apache_container_name }}" sh -lc 'tail -n 100 ${APACHE_LOG_DIR:-/var/log/apache2}/error.log'
      register: apache_error_tail
      changed_when: false
      failed_when: false
      tags: [smoke]

    - name: Summarize /src failure
      debug:
        msg:
          - "STATUS={{ src_admin.status | default('n/a') }}"
          - "LOCATION={{ (src_admin.location | default('')) }}"
          - "BODY_START={{ (src_admin.content | default(''))[:300] | replace('\n',' ') }}"
          - "APACHE_ERROR_TAIL:\n{{ apache_error_tail.stdout | default('') }}"
      changed_when: false
      tags: [smoke]

    # Don't fail the whole play while we investigate
    - meta: clear_host_errors

- name: Cache dir should not be web-accessible (403)
  uri:
    url: "{{ gighive_base_url }}/app/cache/"
    validate_certs: "{{ gighive_validate_certs }}"
    status_code: 403
    headers: "{{ {'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else omit }}"
  changed_when: false

# --- TUS verification (external URL) ---

- name: Build variables for TUS checks
  ansible.builtin.set_fact:
    tus_payload: "hello-tus-{{ ansible_facts['date_time'].epoch }}"
    tus_expected_offset: "{{ ('hello-tus-' ~ ansible_facts['date_time'].epoch) | length }}"
    tus_upload_metadata_filename_b64: "{{ 'verify.wav' | b64encode }}"
    tus_upload_metadata_label_b64: "{{ 'TUS_VALIDATE' | b64encode }}"
    tus_upload_metadata_org_name_b64: "{{ 'gighive' | b64encode }}"
    tus_upload_metadata_event_date_b64: "{{ ansible_facts['date_time'].date | b64encode }}"
    tus_upload_metadata_event_type_b64: "{{ 'band' | b64encode }}"
    tus_headers_common: "{{ {'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else {} }}"
    tus_checks_no_log: "{{ tus_checks_no_log | default(true) }}"
  changed_when: false

- name: Verify tusd container is running
  community.docker.docker_container_info:
    name: "{{ apache_container_name }}_tusd"
  register: tusd_container
  failed_when:
    - not tusd_container.exists
    - not tusd_container.container.State.Running
    - tusd_container.container.State.Restarting
  changed_when: false

- name: Build internal tusd probe URL
  ansible.builtin.set_fact:
    tusd_internal_probe_url: "http://{{ apache_container_name }}_tusd:{{ tusd_port | default(8080) }}{{ tusd_base_path | default('/files') }}/"
  changed_when: false

- name: Probe tusd directly via Docker DNS from inside apache container
  ansible.builtin.command: >
    docker exec {{ apache_container_name }}
    sh -lc "curl -sS -o /dev/null -w '%{http_code}' '{{ tusd_internal_probe_url }}'"
  register: tusd_internal_probe
  changed_when: false
  failed_when: tusd_internal_probe.stdout | trim not in ['200', '204', '404', '405']
  tags: [tus]

- block:
    - name: TUS endpoint should require auth (probe)
      ansible.builtin.uri:
        url: "{{ gighive_base_url }}/files/"
        method: OPTIONS
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ tus_headers_common | combine({'Tus-Resumable': '1.0.0'}) }}"
        status_code: [401, 403]
        return_content: false
      register: tus_auth_probe
      changed_when: false

    - name: Create TUS upload (POST /tus)
      ansible.builtin.uri:
        url: "{{ gighive_base_url }}/files/"
        method: POST
        url_username: "{{ uploader_user }}"
        url_password: "{{ gighive_uploader_password }}"
        force_basic_auth: true
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ tus_headers_common | combine({
          'Tus-Resumable': '1.0.0',
          'Upload-Length': (tus_payload | length) | string,
          'Upload-Metadata': (
            'filename ' ~ tus_upload_metadata_filename_b64 ~
            ',label ' ~ tus_upload_metadata_label_b64 ~
            ',org_name ' ~ tus_upload_metadata_org_name_b64 ~
            ',event_date ' ~ tus_upload_metadata_event_date_b64 ~
            ',event_type ' ~ tus_upload_metadata_event_type_b64
          )
        }) }}"
        status_code: [201]
        return_content: false
      register: tus_create
      changed_when: false
      no_log: "{{ tus_checks_no_log }}"

    - name: Capture upload Location + upload_id
      ansible.builtin.set_fact:
        tus_upload_location: "{{ tus_create.location | default('') }}"
        tus_upload_id: "{{ (tus_create.location | default('')).split('/')[-1] }}"
        tus_public_upload_url: "{{ gighive_base_url }}/files/{{ (tus_create.location | default('')).split('/')[-1] }}"
      changed_when: false

    - name: Assert Location header was returned
      ansible.builtin.assert:
        that:
          - tus_upload_location | length > 0
          - tus_upload_id | length > 0
      changed_when: false

    - name: Upload a small payload via TUS (PATCH)
      ansible.builtin.uri:
        url: "{{ tus_public_upload_url }}"
        method: PATCH
        url_username: "{{ uploader_user }}"
        url_password: "{{ gighive_uploader_password }}"
        force_basic_auth: true
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ tus_headers_common | combine({
          'Tus-Resumable': '1.0.0',
          'Upload-Offset': '0',
          'Content-Type': 'application/offset+octet-stream'
        }) }}"
        body: "{{ tus_payload }}"
        body_format: raw
        status_code: [204]
        return_content: false
      register: tus_patch
      changed_when: false
      no_log: "{{ tus_checks_no_log }}"

    - name: Verify upload offset via TUS (HEAD)
      ansible.builtin.command: >
        sh -lc
        'curl -sS --http1.1 {{ "-k" if not (gighive_validate_certs | default(true)) else "" }} -u "{{ uploader_user }}:{{ gighive_uploader_password }}" -I "{{ tus_public_upload_url }}" -H "Tus-Resumable: 1.0.0" -D - -o /dev/null | tr -d "\r" | awk -F": " "tolower(\$1)==\"upload-offset\"{print \$2; exit}"'
      register: tus_head
      changed_when: false
      failed_when: tus_head.rc not in [0, 18]
      no_log: "{{ tus_checks_no_log }}"

    - name: Extract Upload-Offset header value
      ansible.builtin.set_fact:
        tus_upload_offset_value: "{{ tus_head.stdout | default('') | trim }}"
      changed_when: false

    - name: Assert TUS offset matches payload length
      ansible.builtin.assert:
        that:
          - (tus_upload_offset_value | default('')) | string == (tus_expected_offset | string)
        fail_msg: "Expected Upload-Offset={{ tus_expected_offset }}, got '{{ tus_upload_offset_value | default('') }}'"
      changed_when: false

    - name: Wait for tusd post-finish hook JSON to appear
      ansible.builtin.command: >
        docker exec {{ apache_container_name }}
        sh -lc 'test -f "/var/www/private/tus-hooks/uploads/{{ tus_upload_id }}.json"'
      register: tus_hook_wait
      changed_when: false
      retries: 20
      delay: 1
      until: tus_hook_wait.rc == 0
      no_log: "{{ tus_checks_no_log }}"

    - name: Finalize TUS upload (POST /api/uploads/finalize)
      ansible.builtin.uri:
        url: "{{ gighive_base_url }}/api/uploads/finalize"
        method: POST
        url_username: "{{ uploader_user }}"
        url_password: "{{ gighive_uploader_password }}"
        force_basic_auth: true
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ ({'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else {}) | combine({'Content-Type':'application/json'}) }}"
        body_format: json
        body:
          upload_id: "{{ tus_upload_id }}"
        status_code: 201
        return_content: true
      register: tus_finalize_1
      changed_when: false
      no_log: "{{ tus_checks_no_log }}"

    - name: Finalize again (idempotency)
      ansible.builtin.uri:
        url: "{{ gighive_base_url }}/api/uploads/finalize"
        method: POST
        url_username: "{{ uploader_user }}"
        url_password: "{{ gighive_uploader_password }}"
        force_basic_auth: true
        validate_certs: "{{ gighive_validate_certs }}"
        headers: "{{ ({'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else {}) | combine({'Content-Type':'application/json'}) }}"
        body_format: json
        body:
          upload_id: "{{ tus_upload_id }}"
        status_code: 201
        return_content: true
      register: tus_finalize_2
      changed_when: false
      no_log: "{{ tus_checks_no_log }}"

    - name: Assert finalize idempotency (same file id)
      ansible.builtin.assert:
        that:
          - tus_finalize_1.json is mapping
          - tus_finalize_2.json is mapping
          - (tus_finalize_1.json.id | int) == (tus_finalize_2.json.id | int)
          - (tus_finalize_1.json.file_name | default('')) == (tus_finalize_2.json.file_name | default(''))
      changed_when: false

    - block:
        - name: Assert TUS smoke-test file is safe to delete
          ansible.builtin.assert:
            that:
              - (tus_finalize_1.json.label | default('')) == 'TUS_VALIDATE'
              - (tus_finalize_1.json.file_name | default('')) is search('tus-validate')
              - (tus_finalize_1.json.id | default('') | string) is regex('^[0-9]+$')
            fail_msg: >-
              Refusing to cleanup because finalize response does not look like a TUS_VALIDATE smoke-test file.
              label='{{ tus_finalize_1.json.label | default('') }}' file_name='{{ tus_finalize_1.json.file_name | default('') }}' id='{{ tus_finalize_1.json.id | default('') }}'
          changed_when: false

        - name: Delete TUS smoke-test media record (DB + served file)
          ansible.builtin.uri:
            url: "{{ gighive_base_url }}/db/delete_media_files.php"
            method: POST
            url_username: "admin"
            url_password: "{{ gighive_admin_password }}"
            force_basic_auth: true
            validate_certs: "{{ gighive_validate_certs }}"
            headers: "{{ ({'Host': gighive_hostname_for_host_header} if (gighive_hostname_for_host_header | length) > 0 else {}) | combine({'Content-Type':'application/json'}) }}"
            body_format: json
            body:
              file_ids:
                - "{{ tus_finalize_1.json.id | int }}"
            status_code: [200]
            return_content: true
          register: tus_cleanup_delete
          changed_when: false
          no_log: "{{ tus_checks_no_log }}"

        - name: Assert delete endpoint removed 1 row
          ansible.builtin.assert:
            that:
              - tus_cleanup_delete.json is mapping
              - (tus_cleanup_delete.json.deleted_count | default(0) | int) == 1
              - (tus_cleanup_delete.json.error_count | default(0) | int) == 0
            fail_msg: >-
              Cleanup delete failed. Response={{ tus_cleanup_delete.content | default('') }}
          changed_when: false

        - name: Remove tus staging artifacts for this upload_id
          ansible.builtin.command: >
            docker exec {{ apache_container_name }}
            sh -lc 'rm -f
            "/var/www/private/tus-data/{{ tus_upload_id }}"
            "/var/www/private/tus-hooks/uploads/{{ tus_upload_id }}.json"
            "/var/www/private/tus-hooks/finalized/{{ tus_upload_id }}.json"'
          changed_when: false
          failed_when: false
          no_log: "{{ tus_checks_no_log }}"
      when: tus_cleanup_after_check | default(true)

  tags: [tus]

