---
# roles/validate_app/tasks/main.yml

- name: Install ping and netcat in Apache container
  ansible.builtin.command:
    cmd: docker exec "{{ apache_container_name }}" bash -c "apt update && apt install -y iputils-ping netcat-openbsd"
  register: install_tools
  changed_when: false

- name: Verify restart policy of Apache and MySQL containers
  ansible.builtin.command:
    cmd: docker inspect -f '{% raw %}{{ .HostConfig.RestartPolicy.Name }}{% endraw %}' "{{ apache_container_name }}" "{{ mysql_container_name }}"
  register: restart_policy
  changed_when: false

- name: Display Restart Policy Result
  ansible.builtin.debug:
    msg: "{{ restart_policy.stdout_lines }}"

- name: Read MySQL root password from .env.mysql
  ansible.builtin.slurp:
    src: "{{ configs_dir }}/.env.mysql"
  register: env_file

- name: Extract MYSQL_ROOT_PASSWORD from env file
  set_fact:
    mysql_root_password: "{{ (env_file.content | b64decode).splitlines() | select('search', '^MYSQL_ROOT_PASSWORD=') | map('regex_replace', '^MYSQL_ROOT_PASSWORD=', '') | list | first }}"

- name: Wait for MySQL inside container to become ready
  ansible.builtin.command:
    argv:
      - docker
      - exec
      - -e
      - "MYSQL_PWD={{ mysql_root_password }}"
      - "{{ mysql_container_name }}"
      - mysqladmin
      - ping
      - -h127.0.0.1
      - -uroot
      - --silent
  register: ping_result
  changed_when: false
  until: ping_result.rc == 0
  retries: 60        # try up to 2 minutes total
  delay: 2
  no_log: true       # masks args/stdout/stderr in Ansible output

- name: Run SQL script from external file and display output
  ansible.builtin.shell: |
    echo "Running SQL script..."
    docker exec -i "{{ mysql_container_name }}" mysql -uroot -p{{ mysql_root_password }} -D music_db < "{{ dbscripts_dir }}/select.sql"
  register: sql_output
  changed_when: false

- name: Show SQL result
  ansible.builtin.debug:
    msg: "{{ sql_output.stdout_lines }}"

- name: Ensure web root exists
  ansible.builtin.stat:
    path: "{{ web_root }}"
  register: web_root_status

- name: Fail if web root is missing
  ansible.builtin.fail:
    msg: "Web root directory {{ web_root }} does not exist on remote host."
  when: not web_root_status.stat.exists

- name: Check that index.php exists and is readable
  ansible.builtin.stat:
    path: "{{ web_root }}/index.php"
  register: index_status

- name: Fail if index.php is missing or unreadable
  ansible.builtin.fail:
    msg: "index.php is missing or not readable in {{ web_root }}"
  when: not index_status.stat.exists or not index_status.stat.readable

- name: Check ownership and mode of web root
  ansible.builtin.stat:
    path: "{{ web_root }}"
  register: perms

- name: Warn if web root is not owned by ansible_user:www-data or not mode 0775
  ansible.builtin.debug:
    msg: "Ownership or permissions might block Apache: Owner={{ perms.stat.pw_name }}, Group={{ perms.stat.gr_name }}, Mode={{ perms.stat.mode }}"
  when: perms.stat.pw_name != ansible_user or perms.stat.gr_name != 'www-data' or perms.stat.mode != '0775'

- name: Check for required PHP files in web root
  ansible.builtin.find:
    paths: "{{ web_root }}"
    patterns:
      - index.php
      - robots.txt
    recurse: no
  register: file_check

- name: Warn if required PHP files are missing
  ansible.builtin.debug:
    msg: "Expected files missing: index.php and robots.txt"
  when: file_check.matched < 2

- name: Run curl smoke test inside Apache container
  ansible.builtin.shell: |
    docker exec "{{ apache_container_name }}" curl -sk https://localhost/
  register: curl_test
  ignore_errors: yes

- name: Show homepage curl result
  debug:
    var: curl_test.stdout_lines

- name: Test database connectivity via health endpoint (no auth required)
  ansible.builtin.shell: |
    docker exec "{{ apache_container_name }}" curl -sk https://localhost/db/health.php
  register: db_health_test
  changed_when: false
  failed_when: false

- name: Show raw health check output for debugging
  ansible.builtin.debug:
    msg:
      - "Return code: {{ db_health_test.rc }}"
      - "Raw output: {{ db_health_test.stdout }}"
  when: db_health_test.stdout is defined

- name: Parse database health check response
  ansible.builtin.set_fact:
    db_health_json: "{{ db_health_test.stdout | from_json }}"
  when:
    - db_health_test.rc == 0
    - db_health_test.stdout | length > 0
  ignore_errors: true

- name: Display database health check result
  ansible.builtin.debug:
    msg:
      - "Database health status: {{ db_health_json.status | default('unknown') }}"
      - "Message: {{ db_health_json.message | default('No response') }}"
      - "Error: {{ db_health_json.error | default('none') }}"
  when: db_health_json is defined

- name: Fail if database health check failed
  ansible.builtin.fail:
    msg: "Database health check failed: {{ db_health_json.message | default('Unknown error') }}"
  when:
    - db_health_json is defined
    - db_health_json.status != 'ok'

- name: Ensure test upload file for media-files API exists
  ansible.builtin.copy:
    dest: /tmp/gighive-test-upload.txt
    content: "1234567890\n"
    mode: "0644"

- name: Validate POST /api/media-files works
  ansible.builtin.uri:
    url: "{{ gighive_base_url }}/api/media-files"
    method: POST
    url_username: "{{ uploader_user }}"
    url_password: "{{ gighive_uploader_password }}"
    force_basic_auth: yes
    validate_certs: yes
    body_format: form-multipart
    body:
      mediafile: "@/tmp/gighive-test-upload.txt"
      title: "ansible-test-upload"
    return_content: yes
    status_code: [200, 201]
  register: media_files_post
  failed_when: false

- name: Assert POST /api/media-files response is valid (when implemented)
  ansible.builtin.assert:
    that:
      - media_files_post.status in [200, 201]
      - media_files_post.json is defined
      - media_files_post.json.id is defined
    fail_msg: "POST /api/media-files did not return expected JSON with id"
  when: media_files_post.status is defined and media_files_post.status in [200, 201]

- name: Validate GET /api/media-files works
  ansible.builtin.uri:
    url: "{{ gighive_base_url }}/api/media-files"
    method: GET
    url_username: "{{ uploader_user }}"
    url_password: "{{ gighive_uploader_password }}"
    force_basic_auth: yes
    validate_certs: yes
    return_content: yes
    status_code: [200, 501, 404]
  register: media_files_get
  failed_when: false

- name: Assert GET /api/media-files returns JSON when implemented
  ansible.builtin.assert:
    that:
      - media_files_get.status == 200
      - media_files_get.json is defined
    fail_msg: "GET /api/media-files did not return valid JSON when implemented"
  when: media_files_get.status is defined and media_files_get.status == 200

- name: Read host timezone via /etc/localtime symlink
  become: true
  ansible.builtin.command:
    cmd: readlink -f /etc/localtime
  register: host_localtime_link
  changed_when: false

- name: Assert host timezone matches expected
  ansible.builtin.assert:
    that:
      - host_localtime_link.stdout | trim == ("/usr/share/zoneinfo/" ~ gighive_timezone)
    fail_msg: "Host /etc/localtime resolves to {{ host_localtime_link.stdout | trim }}, expected /usr/share/zoneinfo/{{ gighive_timezone }}"

- name: Read apache container timezone
  ansible.builtin.command:
    cmd: docker exec -i "{{ apache_container_name }}" cat /etc/timezone
  register: apache_timezone
  changed_when: false

- name: Assert apache container timezone matches expected
  ansible.builtin.assert:
    that:
      - apache_timezone.stdout | trim == gighive_timezone
    fail_msg: "{{ apache_container_name }} timezone is {{ apache_timezone.stdout | trim }}, expected {{ gighive_timezone }}"

- name: Read mysql container TZ env
  ansible.builtin.command:
    cmd: docker exec -i "{{ mysql_container_name }}" printenv TZ
  register: mysql_tz_env
  changed_when: false

- name: Assert mysql container TZ env matches expected
  ansible.builtin.assert:
    that:
      - mysql_tz_env.stdout | trim == gighive_timezone
    fail_msg: "{{ mysql_container_name }} TZ env is {{ mysql_tz_env.stdout | trim }}, expected {{ gighive_timezone }}"

- name: Read mysql container timezone
  ansible.builtin.command:
    cmd: docker exec -i "{{ mysql_container_name }}" cat /etc/timezone
  register: mysql_timezone
  changed_when: false

- name: Assert mysql container timezone matches expected
  ansible.builtin.assert:
    that:
      - mysql_timezone.stdout | trim == gighive_timezone
    fail_msg: "{{ mysql_container_name }} timezone is {{ mysql_timezone.stdout | trim }}, expected {{ gighive_timezone }}"

