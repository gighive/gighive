# Basic VM configuration
hostname: "prod"
vm_name: "prod"

enable_vbox_vm_autostart: false
vbox_autostart_debug: false

gighive_timezone: "America/New_York"

# OS version configuration
ubuntu_version: "24.04"
ubuntu_codename: "noble"

static_ip: "{{ ansible_host }}"
gateway: "192.168.1.1"
nameservers:
  - "8.8.8.8"
  - "8.8.4.4"
bridge_iface: "enp8s0"
#disk_size_mb: 222000
disk_size_mb: 64000

# Ansible host specific paths (user = sodo) THESE ARE SOURCES FOR VIDEOS and AUDIO FILES, LEAVING ABSOLUTE
video_full: "/home/sodo/videos/stormpigs/finals/singles/"
audio_full: "/home/sodo/scripts/stormpigsCode/production/audio/"
video_reduced: "{{ repo_root }}/assets/video"
audio_reduced: "{{ repo_root }}/assets/audio"

media_search_dir_audio: "/var/www/html/audio"
media_search_dir_video: "/var/www/html/video"
media_search_dirs: "{{ media_search_dir_audio }}:{{ media_search_dir_video }}"

# vmdk/vdi specs for local vm
# Cloud image URL format (verified 2024-11 for Noble 24.04)
# Format may change; check https://cloud-images.ubuntu.com/ if download fails
cloud_image_url: "https://cloud-images.ubuntu.com/{{ ubuntu_codename }}/current/{{ ubuntu_codename }}-server-cloudimg-amd64.vmdk"
cloud_image_dir: "{{ cloud_init_files_dir }}"
cloud_image_vmdk: "{{ cloud_init_files_dir }}/{{ ubuntu_codename }}-server-cloudimg-amd64-{{ vm_name }}.vmdk"
cloud_image_vdi: "{{ cloud_init_files_dir }}/{{ ubuntu_codename }}-server-cloudimg-amd64-{{ vm_name }}.vdi"
nocloud_iso: "{{ cloud_init_files_dir }}/seed-{{ vm_name }}.iso"

ansible_remote_tmp: "/tmp/.ansible/tmp"

# app flavor for build-time overlay; database_full kept as-is
app_flavor: defaultcodebase
database_full: true

# Docker container rebuild control
rebuild_mysql: false       # Rebuild MySQL container (preserve data)
rebuild_mysql_data: false # Rebuild MySQL container + wipe database (nuclear)

# these vars control full/reduced set of media
sync_video: true
reduced_video: false
sync_audio: true
reduced_audio: false

# --------------------------------------------------------------------
# upload_tests role
# --------------------------------------------------------------------
upload_test_restore_only: false
upload_test_restore_db_after: true

upload_test_mode: false
allow_destructive: false
upload_test_destructive_confirm: true

upload_tests_csv_dir: "{{ repo_root }}/ansible/fixtures/upload_tests/csv"

upload_test_manifest_source_roots_reload:
  - "{{ video_reduced }}"
upload_test_manifest_source_roots_add:
  - "{{ audio_reduced }}"

upload_test_event_date: "{{ ansible_date_time.date }}"
upload_test_org_name: "default"
upload_test_event_type: "band"

upload_test_variants:
  - name: "3a_legacy_import_gighive"
    section: "3a"
    app_flavor: "gighive"
  - name: "3a_legacy_import_defaultcodebase"
    section: "3a"
    app_flavor: "defaultcodebase"
  - name: "3b_normalized_import_gighive"
    section: "3b"
    app_flavor: "gighive"
  - name: "3b_normalized_import_defaultcodebase"
    section: "3b"
    app_flavor: "defaultcodebase"
  - name: "4_manifest_reload"
    section: "4"
  - name: "5_manifest_add"
    section: "5"

upload_test_run_upload_media_by_hash: false
upload_test_ssh_target: "{{ ansible_user }}@{{ gighive_host }}"

# --------------------------------------------------------------------
# Supported media formats (centralized for PHP upload validation/inference)
#
# BACKUP (original hardcoded PHP lists before centralization):
#
# UploadValidator.php default allowed MIME allowlist:
#   audio/mpeg
#   audio/mp3
#   audio/wav
#   audio/x-wav
#   audio/aac
#   audio/flac
#   audio/mp4
#   video/mp4
#   video/quicktime
#   video/x-matroska
#   video/webm
#   video/x-msvideo
#
# UploadService.php inferType() fallback extensions:
#   audio: mp3, wav, flac, aac
#   video: mp4, mov, mkv, webm
# --------------------------------------------------------------------
 
gighive_upload_allowed_mimes:
  # Original (existing)
  - audio/mpeg
  - audio/mp3
  - audio/wav
  - audio/x-wav
  - audio/aac
  - audio/flac
  - audio/mp4
  - video/mp4
  - video/quicktime
  - video/x-matroska
  - video/webm
  - video/x-msvideo
 
  # Added (audio)
  - audio/aiff
  - audio/x-aiff
  - audio/ogg
  - application/ogg
  - audio/vorbis
  - audio/basic
  - audio/x-au
  - audio/au
  - audio/mp2
  - audio/mpeg2
  - audio/x-ms-wma

  # Added (video)
  - video/mpeg
  - video/mp2t
  - video/MP2T
  - video/ogg
  - video/x-flv
  - application/mxf
  - video/mxf
  - application/vnd.rn-realmedia
  - audio/vnd.rn-realaudio
  - audio/x-pn-realaudio
  - video/vnd.rn-realvideo
  - video/x-ms-wmv
  - video/x-ms-asf
  - application/vnd.ms-asf
 
gighive_upload_audio_exts:
  # Original (existing)
  - mp3
  - wav
  - flac
  - aac
 
  # Added
  - m4a
  - m4p
  - aif
  - aifc
  - aiff
  - ogg
  - oga
  - au
  - m2a
  - wma
 
gighive_upload_video_exts:
  # Original (existing)
  - mp4
  - mov
  - mkv
  - webm
 
  # Added
  - m4v
  - avi
  - mpg
  - mpeg
  - ts
  - m2t
  - m2ts
  - ogv
  - mxf
  - flv
  - rm
  - rmvb
  - rv
  - wmv
  - vob
  - m2v
  - bup
  - ifo

# Users
admin_user: admin
viewer_user: viewer
uploader_user: uploader
guest_user: guest
 
# htpasswd locations, one on the host, other on the container
# gighive_apache_container: "{{ apache_container_name }}"
gighive_htpasswd_host_path: "{{ docker_dir }}/apache/externalConfigs/gighive.htpasswd"  # on the host
gighive_htpasswd_path: /var/www/private/gighive.htpasswd                  # inside the container
 
# resize request locations, one on the host, other on the container
gighive_resize_requests_host_path: "{{ docker_dir }}/apache/externalConfigs/resizerequests"  # on the host
gighive_resize_requests_path: /var/www/private/resizerequests                                # inside the container

# resize request directory permissions
gighive_resize_requests_owner: www-data
gighive_resize_requests_group: www-data
gighive_resize_requests_mode: "0750"

# for password reset 
gighive_htpasswd_owner: www-data
gighive_htpasswd_group: www-data
gighive_htpasswd_mode: "0640"

# gighive.yml (example additions—use Vault for passwords!)
apache_group: www-data

# htpasswd vars coming up
protected_paths: ['app','api','db','debug','src','vendor']

# --------------------------------------------------------------------
# TUS (tusd) uploads
# --------------------------------------------------------------------
# NOTE: tusd runs in its own container, but shares volumes with the apache
# container. Using numeric uid/gid here avoids relying on user names existing
# inside the tusd image.
tusd_user_uid: 33
tusd_user_gid: 33

# tusd internal listen port (container)
tusd_port: 8080

# tusd internal base path (what tusd serves)
tusd_base_path: "/files"

# public path exposed via Apache reverse proxy
tus_public_path: "/files"

# tusd container paths
tusd_upload_dir: "/srv/tusd-data/data"
tusd_hooks_dir: "/hooks"
tusd_hook_out_dir: "/hook-out"

# apache container paths for shared volumes
tus_data_dir: "/var/www/private/tus-data"
tus_hooks_dir: "/var/www/private/tus-hooks"

# post_build_checks tunables
tus_hook_wait_retries: 20
tus_hook_wait_delay_seconds: 1
tus_checks_no_log_default: true

# tus-js-client chunk size (bytes). Keep below Cloudflare request limits.
tus_client_chunk_size_bytes: 8388608

#gighive_host — what tests hit (can be IP or hostname)
#gighive_server_name — what goes into the cert (CN + DNS.1)
#gighive_server_alias — what goes into the cert (CN + DNS.1)

gighive_scheme: "https"
gighive_host: "{{ ansible_host }}"                  # can be an IP or hostname
gighive_validate_certs: false
gighive_hostname_for_host_header: ""     # set to "gighive" when using IP
gighive_base_url: "{{ gighive_scheme }}://{{ gighive_host }}"
gighive_auth_probe_url: "{{ gighive_scheme }}://{{ gighive_host }}/db/database.php"
gighive_auth_probe_insecure: true

# --- Naming strategy (gighive2/dev test) ---
# Certificate identity (TLS only)
gighive_cert_cn: "gighive.internal"
gighive_cert_dns_sans:
  - "*.gighive.internal"
  - "gighive.internal"
  - "*.gighive.app"
  - "www.stormpigs.com"

# Host identity (Apache / what clients connect to)
gighive_fqdn: "gighive.gighive.internal"

# Optional additional names for the vhost
gighive_server_aliases:
  - "gighive.gighive.internal"
  - "gighive2.gighive.internal"
  - "dev.gighive.internal"
  - "staging.gighive.internal"
  - "lab.gighive.internal"
  - "staging.gighive.app"
  - "lab.gighive.app"
  - "www.stormpigs.com"

# Back-compat mapping (keep during testing; remove later once everything migrates)
gighive_server_name: "{{ gighive_fqdn }}"
gighive_server_alias: "{{ (gighive_server_aliases | default([])) | first | default('gighive') }}"
gighive_ssl_cert_file: "/etc/ssl/certs/origin_cert.pem"
gighive_ssl_key_file:  "/etc/ssl/private/origin_key.pem"
gighive_ssl_san_config: "/etc/ssl/openssl_san.cnf"
gighive_php_version: "8.3"
gighive_php_fpm_bin: "php-fpm{{ gighive_php_version }}"

# If you use custom-compiled httpd in the container:
apache_graceful_cmd: "/usr/local/apache2/bin/httpd -k graceful"

# htpasswd seed vars
gighive_htpasswd_seed_once: true
gighive_htpasswd_marker_path: "{{ gighive_htpasswd_host_path }}.seeded"

# --- Apache container ---
apache_container_name: apacheWebServer

# --- MySQL db/user ---
mysql_database: music_db
mysql_user: appuser
mysql_db_host: mysqlServer
mysql_container_name: "{{ mysql_db_host }}"

# --- DB migrations role vars ---
db_migrations_mysql_ready_retries: 60
db_migrations_mysql_ready_delay_seconds: 2

# --- MySQL backup role vars ---
mysql_backup_user: "{{ ansible_user }}"

# Paths derive from the facts you set in site.yml pre_tasks:
mysql_env_file: "{{ configs_dir }}/.env.mysql"
mysql_backup_script_dir: "{{ dbscripts_dir }}"
mysql_backups_dir: "{{ dbscripts_dir }}/backups"

# Scheduling
mysql_dump_hour: "2"
mysql_dump_minute: "10"
mysql_prune_hour: "3"
mysql_prune_minute: "5"

# Retention
mysql_backup_retention_days: 90 

# Log file for cron jobs
mysql_backup_log: "{{ mysql_backups_dir }}/cron.log"

# --- App upload/filename settings ---
filename_seq_pad: 5
upload_max_bytes: 6442450944 
upload_max_mb: 6144

database_pagination_threshold: 750
