# Basic VM configuration
hostname: "gighive"
vm_name: "gighive"

gighive_timezone: "America/New_York"

# OS version configuration
ubuntu_version: "24.04"
ubuntu_codename: "noble"

static_ip: "{{ ansible_host }}"
gateway: "192.168.1.1"
nameservers:
  - "8.8.8.8"
  - "8.8.4.4"
bridge_iface: "enp8s0"
#disk_size_mb: 222000
disk_size_mb: 64000

# Ansible host specific paths (user = sodo) THESE ARE SOURCES FOR VIDEOS and AUDIO FILES, LEAVING ABSOLUTE
video_full: "/home/sodo/videos/stormpigs/finals/singles/"
audio_full: "/home/sodo/scripts/stormpigsCode/production/audio/"
video_reduced: "{{ repo_root }}/assets/video"
audio_reduced: "{{ repo_root }}/assets/audio"

media_search_dir_audio: "/var/www/html/audio"
media_search_dir_video: "/var/www/html/video"
media_search_dirs: "{{ media_search_dir_audio }}:{{ media_search_dir_video }}"

# vmdk/vdi specs for local vm
# Cloud image URL format (verified 2024-11 for Noble 24.04)
# Format may change; check https://cloud-images.ubuntu.com/ if download fails
cloud_image_url: "https://cloud-images.ubuntu.com/{{ ubuntu_codename }}/current/{{ ubuntu_codename }}-server-cloudimg-amd64.vmdk"
cloud_image_dir: "{{ cloud_init_files_dir }}"
cloud_image_vmdk: "{{ cloud_init_files_dir }}/{{ ubuntu_codename }}-server-cloudimg-amd64-{{ vm_name }}.vmdk"
cloud_image_vdi: "{{ cloud_init_files_dir }}/{{ ubuntu_codename }}-server-cloudimg-amd64-{{ vm_name }}.vdi"
nocloud_iso: "{{ cloud_init_files_dir }}/seed-{{ vm_name }}.iso"

ansible_remote_tmp: "/tmp/.ansible/tmp"

# app flavor for build-time overlay; database_full kept as-is
app_flavor: gighive
database_full: false

# Docker container rebuild control
rebuild_mysql: false       # Rebuild MySQL container (preserve data)
rebuild_mysql_data: false # Rebuild MySQL container + wipe database (nuclear)

# these vars control full/reduced set of media
sync_video: true
reduced_video: true
sync_audio: true
reduced_audio: true

# --------------------------------------------------------------------
# Supported media formats (centralized for PHP upload validation/inference)
#
# BACKUP (original hardcoded PHP lists before centralization):
#
# UploadValidator.php default allowed MIME allowlist:
#   audio/mpeg
#   audio/mp3
#   audio/wav
#   audio/x-wav
#   audio/aac
#   audio/flac
#   audio/mp4
#   video/mp4
#   video/quicktime
#   video/x-matroska
#   video/webm
#   video/x-msvideo
#
# UploadService.php inferType() fallback extensions:
#   audio: mp3, wav, flac, aac
#   video: mp4, mov, mkv, webm
# --------------------------------------------------------------------
 
gighive_upload_allowed_mimes:
  # Original (existing)
  - audio/mpeg
  - audio/mp3
  - audio/wav
  - audio/x-wav
  - audio/aac
  - audio/flac
  - audio/mp4
  - video/mp4
  - video/quicktime
  - video/x-matroska
  - video/webm
  - video/x-msvideo
 
  # Added (audio)
  - audio/aiff
  - audio/x-aiff
  - audio/ogg
  - application/ogg
  - audio/vorbis
  - audio/basic
  - audio/x-au
  - audio/au
  - audio/mp2
  - audio/mpeg2
  - audio/x-ms-wma

  # Added (video)
  - video/mpeg
  - video/mp2t
  - video/MP2T
  - video/ogg
  - video/x-flv
  - application/mxf
  - video/mxf
  - application/vnd.rn-realmedia
  - audio/vnd.rn-realaudio
  - audio/x-pn-realaudio
  - video/vnd.rn-realvideo
  - video/x-ms-wmv
  - video/x-ms-asf
  - application/vnd.ms-asf
 
gighive_upload_audio_exts:
  # Original (existing)
  - mp3
  - wav
  - flac
  - aac
 
  # Added
  - m4a
  - m4p
  - aif
  - aifc
  - aiff
  - ogg
  - oga
  - au
  - m2a
  - wma
 
gighive_upload_video_exts:
  # Original (existing)
  - mp4
  - mov
  - mkv
  - webm
 
  # Added
  - m4v
  - avi
  - mpg
  - mpeg
  - ts
  - m2t
  - m2ts
  - ogv
  - mxf
  - flv
  - rm
  - rmvb
  - rv
  - wmv
  - vob
  - m2v
  - bup
  - ifo

# Users
admin_user: admin
viewer_user: viewer
uploader_user: uploader

# htpasswd locations, one on the host, other on the container
gighive_apache_container: apacheWebServer
gighive_htpasswd_host_path: "{{ docker_dir }}/apache/externalConfigs/gighive.htpasswd"  # on the host
gighive_htpasswd_path: /var/www/private/gighive.htpasswd                  # inside the container

# resize request locations, one on the host, other on the container
gighive_resize_requests_host_path: "{{ docker_dir }}/apache/externalConfigs/resizerequests"  # on the host
gighive_resize_requests_path: /var/www/private/resizerequests                                # inside the container

# resize request directory permissions
gighive_resize_requests_owner: www-data
gighive_resize_requests_group: www-data
gighive_resize_requests_mode: "0750"

# for password reset 
gighive_htpasswd_owner: www-data
gighive_htpasswd_group: www-data
gighive_htpasswd_mode: "0640"

# gighive.yml (example additions—use Vault for passwords!)
apache_group: www-data

# htpasswd vars coming up
protected_paths: ['app','api','db','debug','src','vendor']

#gighive_host — what tests hit (can be IP or hostname)
#gighive_server_name — what goes into the cert (CN + DNS.1)
#gighive_server_alias — what goes into the cert (CN + DNS.1)

gighive_scheme: "https"
gighive_host: "gighive"                  # can be an IP or hostname
gighive_validate_certs: false
gighive_hostname_for_host_header: ""     # set to "gighive" when using IP
gighive_base_url: "{{ gighive_scheme }}://{{ gighive_host }}"
gighive_auth_probe_url: "{{ gighive_scheme }}://{{ gighive_host }}/db/database.php"
gighive_auth_probe_insecure: true

gighive_server_name: "{{ vm_name | default(inventory_hostname) }}" # name in cert
gighive_server_alias: "gighive" # alias in cert
gighive_ssl_cert_file: "/etc/ssl/certs/origin_cert.pem"
gighive_ssl_key_file:  "/etc/ssl/private/origin_key.pem"
gighive_ssl_san_config: "/etc/ssl/openssl_san.cnf"
gighive_php_version: "8.3"
gighive_php_fpm_bin: "php-fpm{{ gighive_php_version }}"

# If you use custom-compiled httpd in the container:
apache_graceful_cmd: "/usr/local/apache2/bin/httpd -k graceful"

# htpasswd seed vars
gighive_htpasswd_seed_once: true
gighive_htpasswd_marker_path: "{{ gighive_htpasswd_host_path }}.seeded"

# --- MySQL db/user ---
mysql_database: music_db
mysql_user: appuser

# --- MySQL backup role vars ---
mysql_backup_user: "{{ ansible_user }}"

# Paths derive from the facts you set in site.yml pre_tasks:
mysql_env_file: "{{ configs_dir }}/.env.mysql"
mysql_backup_script_dir: "{{ dbscripts_dir }}"
mysql_backups_dir: "{{ dbscripts_dir }}/backups"

# Scheduling
mysql_dump_hour: "2"
mysql_dump_minute: "10"
mysql_prune_hour: "3"
mysql_prune_minute: "5"

# Retention
mysql_backup_retention_days: 90 

# Log file for cron jobs
mysql_backup_log: "{{ mysql_backups_dir }}/cron.log"

# --- App upload/filename settings ---
filename_seq_pad: 5
upload_max_bytes: 6442450944 
upload_max_mb: 6144

database_pagination_threshold: 750
