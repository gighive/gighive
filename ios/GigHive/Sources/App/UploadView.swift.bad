import SwiftUI
import UniformTypeIdentifiers

struct LabeledField<Content: View>: View {
    let label: String
    let helper: String?
    @ViewBuilder var content: Content

    init(_ label: String, helper: String? = nil, @ViewBuilder content: () -> Content) {
        self.label = label
        self.helper = helper
        self.content = content()
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            GHLabel(text: label)
            content
            if let helper, !helper.isEmpty {
                Text(helper).font(.footnote).ghForeground(GHTheme.muted)
            }
        }
    }
}

struct UploadView: View {
    // SERVER
    @AppStorage("gh_server_url") private var serverURLString: String = "https://gighive" // editable by user
    @AppStorage("gh_basic_user") private var username: String = ""
    @AppStorage("gh_basic_pass") private var password: String = ""
    @AppStorage("gh_eventType_default") private var storedEventType: String = "band"

    @State private var fileURL: URL?
    @State private var eventDate = Date()
    @State private var orgName = ""
    @State private var eventType = "band"
    @State private var label = ""
    @State private var autogenLabel = false
    @State private var showPhotosPicker = false
    @State private var showFilesPicker = false
    @State private var isUploading = false
    @State private var isCancelling = false
    @State private var showResultAlert = false
    @State private var alertTitle = ""
    @State private var alertMessage = ""
    @State private var debugLog: [String] = []
    @State private var successURL: URL?
    @State private var failureCount: Int = 0
    @State private var uploadTask: Task<Void, Never>? = nil
    @State private var lastButtonStatus: String? = nil
    @State private var currentUploadClient: UploadClient? = nil
    @State private var allowInsecureTLS = false
    @State private var isLoadingMedia = false
    @State private var loadedFileSize: String? = nil
    @State private var lastProgressBucket: Int = 0

    let onUpload: (UploadPayload) -> Void
    @Environment(\.openURL) private var openURL

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                HStack(spacing: 8) {
                    Image("beelogo")
                        .resizable()
                        .scaledToFit()
                        .frame(height: UIFont.preferredFont(forTextStyle: .title2).pointSize + 2)
                    Text("Gighive Upload")
                        .font(.title3).bold()
                        .ghForeground(GHTheme.text)
                }

                // SERVER CARD
                GHCard(pad: 8) {
                    VStack(alignment: .leading, spacing: 2) {
                        GHLabel(text: "SERVER")

                        LabeledField("") {
                            TextField("https://example.com", text: $serverURLString)
                                .keyboardType(.URL)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 2)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 24)
                        }

                        LabeledField("Username *") {
                            TextField("admin/uploader username", text: $username)
                                .keyboardType(.default)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 3)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 28)
                        }

                        LabeledField("Password *") {
                            SecureField("password", text: $password)
                                .keyboardType(.default)
                                .ghNoAutocapitalization()
                                .disableAutocorrection(true)
                                .font(.footnote)
                                .padding(.vertical, 3)
                                .padding(.horizontal, 8)
                                .ghForeground(GHTheme.text)
                                .ghTint(GHTheme.caret)
                                .ghBackgroundMaterial()
                                .cornerRadius(6)
                                .frame(height: 28)
                        }

                        // Default event type removed from SERVER: we persist the META selection instead.
                    }
                }

                LabeledField("Media file (audio/video) *") {
                    Menu {
                        Button("Choose File") {
                            showPhotosPicker = true
                        }
                        Button("From Files") { 
                            showFilesPicker = true 
                        }
                    } label: {
                        HStack {
                            Image(systemName: "paperclip")
                            Text(fileURL?.lastPathComponent ?? "Choose File")
                                .lineLimit(1)
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(GHTheme.accent, lineWidth: 1.5)
                                .background(GHTheme.card.opacity(0.3))
                        )
                        .cornerRadius(10)
                    }
                    if let fileSize = loadedFileSize {
                        Text("File size: \(fileSize)")
                            .font(.caption2)
                            .foregroundColor(.red)
                    }
                }

                LabeledField("Event date *") {
                    DatePicker("", selection: $eventDate, displayedComponents: .date)
                        .labelsHidden()
                        .datePickerStyle(CompactDatePickerStyle())
                        .ghForeground(GHTheme.text)
                        .environment(\.colorScheme, .dark)
                }

                LabeledField("Band or wedding party name *") {
                    TextField("", text: $orgName)
                        .keyboardType(.default)
                        .ghWordsAutocap()
                        .disableAutocorrection(true)
                        .font(.footnote)
                        .padding(.vertical, 2)
                        .padding(.horizontal, 8)
                        .ghForeground(GHTheme.text)
                        .ghTint(GHTheme.caret)
                        .ghBackgroundMaterial()
                        .cornerRadius(6)
                        .frame(height: 24)
                }

                LabeledField("Event type *") {
                    Picker("", selection: $eventType) {
                        Text("band").tag("band")
                        Text("wedding").tag("wedding")
                    }
                    .pickerStyle(.segmented)
                }

                LabeledField("Song title or wedding table / identifier *") {
                    TextField("", text: $label)
                        .keyboardType(.default)
                        .disableAutocorrection(true)
                        .font(.footnote)
                        .padding(.vertical, 2)
                        .padding(.horizontal, 8)
                        .ghForeground(GHTheme.text)
                        .ghTint(GHTheme.caret)
                        .ghBackgroundMaterial()
                        .cornerRadius(6)
                        .frame(height: 24)
                }

                Toggle(isOn: $autogenLabel) {
                    GHLabel(text: "Autogenerate label?")
                }
                .ghTint(GHTheme.accent)

                if autogenLabel {
                    Text("If checked, the label will be set to \"Auto YYYY-MM-DD\" based on the Event date.")
                        .ghForeground(GHTheme.muted)
                }

                Button(isCancelling ? "Cancelling…" : (isUploading ? "Uploading…" : (lastButtonStatus ?? "Upload")), action: {
                            if isUploading {
                                // Second press: cancel
                                isCancelling = true
                                debugLog.append("cancelling…")
                                uploadTask?.cancel()
                                
                                // Also cancel the underlying network upload task
                                currentUploadClient?.cancelCurrentUpload()
                            } else {
                                doUpload()
                            }
                        })
                            .buttonStyle(GHButtonStyle(color: lastButtonStatus == "Upload Cancelled" ? .red : GHTheme.accent))
                            .disabled((!isUploading) && (isLoadingMedia || fileURL == nil || (label.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)))
                            .padding(.top, 2)

                        if !debugLog.isEmpty {
                            Text(debugLog.joined(separator: " → "))
                                .font(.caption2)
                                .foregroundColor(.red)
                                .padding(.top, 2)
                        }


                        if let url = successURL {
                            Link("View in database", destination: url)
                                .font(.caption)
                                .ghForeground(GHTheme.accent)
                                .padding(.top, 2)
                        }

                        Toggle(isOn: $allowInsecureTLS) {
                            Text("Disable Certificate Checking").font(.caption2).ghForeground(GHTheme.muted)
                        }
                        .ghTint(GHTheme.accent)
                        .padding(.top, 4)

                        Button(action: hideKeyboard) {
                            Text("Hide Keyboard").font(.caption)
                        }
                        .padding(.top, 2)

                        if failureCount >= 5 {
                            if let mail = makeSupportEmailLink() {
                                Link("Email administrator with debug log", destination: mail)
                                    .font(.caption)
                                    .foregroundColor(.red)
                                    .padding(.top, 2)
                            }
                        }
                    }
                }
            }
            .frame(maxWidth: .infinity, alignment: .topLeading)
            .padding(8)
        }
        .ghFullScreenBackground(GHTheme.bg)
        .sheet(isPresented: $showPhotosPicker) {
            PHPickerView { url in
                fileURL = url
                showPhotosPicker = false
                if let url = url {
                    // Calculate and show file size
                    do {
                        let fileSize = try url.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
                        let fileSizeText = ByteCountFormatter.string(fromByteCount: Int64(fileSize), countStyle: .file)
                        loadedFileSize = fileSizeText
                    } catch {
                        loadedFileSize = "unknown"
                    }
                } else {
                    loadedFileSize = nil
                }
            }
            .modifier(PresentationDetentsCompat())
        }
        .sheet(isPresented: $showFilesPicker) {
            DocumentPickerView(
                allowedTypes: [
                    UTType.movie,
                    UTType.mpeg4Movie,
                    UTType.audio,
                    UTType.mp3
                ],
                onPick: { url in
                    fileURL = url
                    showFilesPicker = false
                    if let url = url {
                        // Calculate and show file size
                        do {
                            let fileSize = try url.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
                            let fileSizeText = ByteCountFormatter.string(fromByteCount: Int64(fileSize), countStyle: .file)
                            loadedFileSize = fileSizeText
                        } catch {
                            loadedFileSize = "unknown"
                        }
                    } else {
                        loadedFileSize = nil
                    }
                }
            )
            .modifier(PresentationDetentsCompat())
        }
        .onChange(of: autogenLabel) { on in if on { label = autoLabel() }; resetCancelledStatus() }
        .onChange(of: eventDate) { _ in if autogenLabel { label = autoLabel() }; resetCancelledStatus() }
        .onChange(of: eventType) { newValue in
            // Persist META selection across app launches
            storedEventType = newValue
            resetCancelledStatus()
        }
        .onChange(of: fileURL) { _ in resetCancelledStatus() }
        .onChange(of: orgName) { _ in resetCancelledStatus() }
        .onChange(of: label) { _ in resetCancelledStatus() }
        .onChange(of: serverURLString) { _ in resetCancelledStatus() }
        .onChange(of: username) { _ in resetCancelledStatus() }
        .onChange(of: password) { _ in resetCancelledStatus() }
        .onAppear {
            // Initialize META picker from the last used value
            eventType = storedEventType
        }
    }

    private func autoLabel() -> String {
        let df = DateFormatter()
        df.dateFormat = "yyyy-MM-dd"
        return "Auto \(df.string(from: eventDate))"
    }

    // Reset the temporary cancelled label back to default when user edits anything
    private func resetCancelledStatus() {
        if lastButtonStatus == "Upload Cancelled" {
            lastButtonStatus = nil
        }
    }

    private func doUpload() {
        debugLog = ["button pressed"]
        guard let fileURL else { debugLog.append("no file chosen"); alertTitle = "Missing file"; alertMessage = "Please choose a media file from Photos or Files."; showResultAlert = true; return }
        
        // Add file size to debug log
        do {
            let fileSize = try fileURL.resourceValues(forKeys: [.fileSizeKey]).fileSize ?? 0
            let fileSizeText = ByteCountFormatter.string(fromByteCount: Int64(fileSize), countStyle: .file)
            debugLog.append("file size: \(fileSizeText)")
        } catch {
            debugLog.append("file size: unknown")
        }
        
        guard let base = URL(string: serverURLString) else { debugLog.append("invalid server url"); alertTitle = "Invalid Server URL"; alertMessage = "Please enter a valid https:// server URL."; showResultAlert = true; return }
        let payload = UploadPayload(
            fileURL: fileURL,
            eventDate: eventDate,
            orgName: orgName,
            eventType: eventType,
            label: label.isEmpty ? nil : label,
            participants: nil, keywords: nil, location: nil, rating: nil, notes: nil
        )
        // Build client using the provided server credentials
        let client = UploadClient(baseURL: base, basicAuth: (username, password), useBackgroundSession: false, allowInsecure: allowInsecureTLS)
        currentUploadClient = client  // Store reference for cancellation
        isUploading = true
        isCancelling = false
        lastButtonStatus = nil
        lastProgressBucket = 0  // Reset progress tracking for new upload
        uploadTask = Task { [serverURLString, orgName, eventType, label] in
            defer { 
                isUploading = false
                isCancelling = false  // Always reset cancelling state when task ends
                loadedFileSize = nil  // Clear file size display after upload completes/cancels
                currentUploadClient = nil  // Clear client reference
            }
            do {
                debugLog.append("contacting server \(serverURLString)")
                // Pre-log the exact request URL to place progress after this line
                let apiURL = base
                    .appendingPathComponent("api")
                    .appendingPathComponent("uploads.php")
                var comps = URLComponents(url: apiURL, resolvingAgainstBaseURL: false)
                comps?.queryItems = [URLQueryItem(name: "ui", value: "json")]
                if let u = comps?.url { debugLog.append("url=\(u.absoluteString)") }
                
                // Show initial progress to let user know progress tracking is active
                debugLog.append("0%..")

                let (status, data, requestURL) = try await client.uploadWithChunking(payload, progress: { completed, total in
                    guard total > 0 else { 
                        print("⚠️ Progress callback: total is 0")
                        return 
                    }
                    let percent = Int((Double(completed) / Double(total)) * 100.0)
                    let bucket = (percent / 10) * 10
                    print("📈 UploadView Progress: \(completed)/\(total) bytes = \(percent)%, bucket=\(bucket), lastBucket=\(lastProgressBucket)")
                    if bucket >= 10 && bucket > lastProgressBucket {
                        DispatchQueue.main.async {
                            lastProgressBucket = bucket
                            debugLog.append("\(bucket)%..")
                            print("✅ Added progress to debug log: \(bucket)%")
                        }
                    }
                })
                debugLog.append("payload=org=\(orgName), type=\(eventType), label=\(label.isEmpty ? "(nil)" : label)")
                debugLog.append("upload finished [\(status)]")
                let bodyText = String(data: data, encoding: .utf8) ?? "(no body)"
                switch status {
                case 201:
                    alertTitle = "Success"
                    alertMessage = "Upload succeeded."
                    let baseURL = base.appendingPathComponent("db").appendingPathComponent("database.php")
                    // Add cache-busting timestamp
                    var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: false)
                    components?.queryItems = [URLQueryItem(name: "t", value: String(Int(Date().timeIntervalSince1970)))]
                    let url = components?.url ?? baseURL
                    successURL = url
                    failureCount = 0
                    debugLog.append("db link=\(url.absoluteString)")
                    // Clear fields after success (update UI on main thread)
                    DispatchQueue.main.async {
                        self.fileURL = nil
                        self.label = ""
                    }
                    debugLog.append("cleared file and label")
                case 401:
                    alertTitle = "Unauthorized"
                    alertMessage = "401 Unauthorized. Check Basic Auth username/password."
                    failureCount += 1
                case 413:
                    alertTitle = "Too Large"
                    alertMessage = "413 Payload Too Large. Pick a smaller file or increase server limits."
                    failureCount += 1
                case 400:
                    alertTitle = "Bad Request"
                    alertMessage = bodyText
                    failureCount += 1
                default:
                    alertTitle = "HTTP \(status)"
                    alertMessage = bodyText
                    failureCount += 1
                }
            } catch is CancellationError {
                // Task was cancelled by user
                debugLog.append("cancelled")
                lastButtonStatus = "Upload Cancelled"
                // Clear selected file after cancellation
                DispatchQueue.main.async {
                    self.fileURL = nil
                }
                // Reset back to default after 5 seconds
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    if lastButtonStatus == "Upload Cancelled" {
                        lastButtonStatus = nil
                    }
                }
                return
            } catch {
                // Map URLError.cancelled to a user-initiated cancel as well
                if let urlErr = error as? URLError, urlErr.code == .cancelled {
                    debugLog.append("cancelled")
                    lastButtonStatus = "Upload Cancelled"
                    // Clear selected file after cancellation
                    DispatchQueue.main.async {
                        self.fileURL = nil
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        if lastButtonStatus == "Upload Cancelled" {
                            lastButtonStatus = nil
                        }
                    }
                    return
                }
                debugLog.append("error: \(error.localizedDescription)")
                alertTitle = "Error"
                alertMessage = error.localizedDescription
                failureCount += 1
            }
            showResultAlert = true
            onUpload(payload)
        }
    }

    private func makeSupportEmailLink() -> URL? {
        let to = "admin@gighive.local" // TODO: replace with real admin address
        let subject = "GigHive iOS Upload Help"
        let body = (debugLog + ["server=\(serverURLString)", "user=\(username)"]).joined(separator: "\n")
        let enc: (String) -> String = { $0.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? $0 }
        return URL(string: "mailto:\(to)?subject=\(enc(subject))&body=\(enc(body))")
    }

    private func hideKeyboard() {
        // iOS 14 safe keyboard dismissal
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
